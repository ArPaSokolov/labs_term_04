# 1) Находим самую нижнюю левую точку, которая будет первой точкой на выпуклой оболочке
# 2) Сортируем остальные точки по полярному углу относительно первой точки
# 3) Проходим по отсортированным точкам и добавляем их в выпуклую оболочку,
# отбрасывая точки, которые образуют "левый поворот"
# 4) Возвращаем выпуклую оболочку в виде списка точек

# Функция для определения ориентации трех точек
def orientation(p, q, r):
    # > 0, если p, q, r "левый поворот"
    # < 0, если p, q, r "правый поворот"
    # = 0, если p, q, r коллинеарны
    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])

def graham_scan(points):
    # Проверка наличия достаточного количества точек
    if len(points) < 3:
        print("Выпуклая оболочка заданного множества точек не существует")
        return []

    # Находим самую нижнюю левую точку
    start_point = min(points, key=lambda p: (p[1], p[0]))

    # Сортируем остальные точки по полярному углу относительно start_point
    sorted_points = sorted(points, key=lambda p: (p[0] - start_point[0], p[1] - start_point[1]))

    # Создаем стек и добавляем первые две точки
    stack = [start_point, sorted_points[0]]

    # Обрабатываем остальные точки
    for i in range(1, len(sorted_points)):
        while len(stack) >= 2 and orientation(stack[-2], stack[-1], sorted_points[i]) <= 0:
            stack.pop()
        stack.append(sorted_points[i])

    return stack

# Пример использования
points = [(0, 0), (1, 1), (2, 2), (3, 1), (2, 0), (1, 2)]
convex_hull = graham_scan(points)
print("Выпуклая оболочка заданного множества точек: ", *convex_hull)
